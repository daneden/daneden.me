import telephone from "./assets/telephone.png"
import basicLayers from "./assets/basic-layers.svg"
import goodLayers from "./assets/good-layers.svg"
import shapesDisparity from "./assets/shapes-disparity.svg"
import shapedParity from "./assets/shapes-parity.svg"
import computer from "./assets/computer.png"
import shapesComputer from "./assets/shapes-computer.svg"
import shapesParityCode from "./assets/shapes-parity-code.svg"
import ideasMedia from "./assets/ideas-media.svg"
import passwordMeterVoiceOver from "./assets/password-meter-voiceover.svg"

export const metadata = {
    title: "Creating Reality",
    description:
        "Code is an incomparably powerful tool for designers, allowing us to create unambiguous, detailed realities that better express our ideas.",
    openGraph: {
        title: "Creating Reality",
        description:
            "Code is an incomparably powerful tool for designers, allowing us to create unambiguous, detailed realities that better express our ideas.",
        images: [
            {
                url: "/og/creating-reality",
            },
        ],
    },
}

# Creating Reality

<Image src={telephone} alt="A green rotary telephone" />

Are you familiar with the game ‚Äútelephone‚Äù? You might know it by a different
name. The first person whispers something into the second person‚Äôs ear; the
second person whispers what they heard into the third person‚Äôs ear, and it
carries on in this manner until you get to the end.

Hold that game in your thoughts; we‚Äôll come back to it. For now, I want to talk
a little bit about a concept in programming called expressivity.

We talk about more modern programming languages and features as being more
‚Äúexpressive‚Äù than what came before. Generally what‚Äôs meant by this is that we
can write code that more clearly and accurately describes our desired result.

React is a good example of this. React is a JavaScript framework for building
user interfaces. It powers many web experiences and even many of mobile
experiences you may use daily. And compared to what came before it, it‚Äôs very
expressive.

Before React, if we wanted to programmatically render a label to the screen, we
might have to write code like this:

```javascript
const label = document.createElement("label")
label.setAttribute("id", "date-label")
label.innerHTML = "Start Date "

const input = document.createElement("input")
input.setAttribute("type", "date")
input.setAttribute("name", "date-input")
label.appendChild(input)

document.body.appendChild(label)
```

Whereas in React, we can write code like this:

```jsx
return (
    <label id="date-label">
        Start Date
        <input type="date" name="date-input" />
    </label>
)
```

We describe code like this as _declarative_, insofar as we are _declaring_ how
an interface should render, instead of describing the procedure for rendering it
(otherwise known as _procedural_ programming).

---

Let‚Äôs take another example. Written communication is both highly expressive and
often ambiguous. Take these examples:

```md
I‚Äôm confused.

Sounds good.

Look at that huge hot dog.
```

Each of these garden-variety sentences can have their entire meaning changed
with some small additions:

```md
I‚Äôm confused. üòÖ

Sounds good. üôÑ

Look at that huge, hot dog.
```

Our first sentence has gone from frustrated to friendly; our second has
transformed from sincere to sarcastic; and our third has changed from delicious
to disgusting.

<Image
    src={basicLayers}
    width={300}
    alt="A layer panel with poorly named and organized layers"
    invertInDarkMode={true}
/>

Design tools have their own inconspicuous expressivity, too. With advancements
of things like auto layout, components, and design tokens, we can infer a lot
more from the _structure_ of our design files than from their appearance alone.

Looking at a layer panel used to not reveal much at all about the design.
Similarly, the mock-ups themselves can be ambiguous: given a grid of elements,
do the elements appear from left-to-right, or top-to-bottom before wrapping?

<Image
    src={goodLayers}
    width={300}
    alt="A layer panel with well named and organized layers"
    invertInDarkMode={true}
/>

When we use the expressivity of tools like auto-layout, these questions find
their answers.

## Disclosure Group

The simple game of telephone is a good demonstration of how a single medium is
not enough to make sure an idea is shared consistently. Wouldn‚Äôt it be easier if
you got to see a picture along with the phrase?

I wanted to share these examples to illustrate the point that design doesn‚Äôt
just happen in design tools. It happens in conversations, writing,
and‚Äîcritically‚Äîit happens in code.

---

> Should Designers Code?

I find this question so reductive, since code is just another tool for
communicating.

It‚Äôs like asking: _Should Designers Write? Speak? Gesture? Prototype? Wireframe?
**Design?**_

<Image
    src={shapesDisparity}
    invertInDarkMode={true}
    alt="Two different people with different ideas in their minds"
/>

Design, in my mind, is the expression of an idea. It‚Äôs the exercise of getting
an idea out of your mind and into the minds of others, through whatever tool we
find most useful. It‚Äôs about creating a shared reality.

<Image
    src={shapedParity}
    invertInDarkMode={true}
    alt="Two different people, both looking at a design tool depicting a mockup. Both people hold the same idea in their minds."
/>

For digital product design, that often means something like a prototype or a
mockup created in Figma. But why stop there?

**Design tools create illusions. Code creates reality.**

Everything that we do in tools like Figma is meaningless to our customers. Apart
from a handful of research participants, no customer will experience your design
as it is expressed in your design tool. They experience whatever your engineers
build, which means that:

**Engineers have the greatest leverage over user experience of anyone in the
company.**

At first, this might seem quite scary. But I think it presents an opportunity
for us to arm ourselves with just enough knowledge to be dangerous. We want to
be able to challenge our engineers to produce the best possible experience. We
want to make sure our intent is adequately expressed in code. So let‚Äôs get to
know who we‚Äôre working with.

---

<Image src={computer} alt="An Apple IIc computer, introduced in 1984" />

Computers are cold, calculating, unforgiving, and incredibly stupid. They deal
only in the simplest terms: 0‚Äôs and 1‚Äôs. Over the years, as technology has
advanced, we‚Äôve been able to build more sophisticated abstractions which allow
us to write code in more expressive, human language, but it all gets compiled
down to the same stuff: turn this circuit on, then off again.

It takes me back to the example of procedural programming from the beginning of
this post. We have to tell the computer _exactly_ what to do, and the order in
which it must do it.

```javascript
const label = document.createElement("label")
label.setAttribute("id", "date-label")
label.innerHTML = "Start Date "

const input = document.createElement("input")
input.setAttribute("type", "date")
input.setAttribute("name", "date-input")
label.appendChild(input)

document.body.appendChild(label)
```

There are two things this tells us:

    1. Computers will only do precisely what they‚Äôre told to do
    2. Any mistakes they make are therefore actually our own

I have a feeling that this is why so many designers not only don‚Äôt exercise
their usual curiosity with code, but actively avoid it. We bury our heads in the
sand at the thought of being confronted by the blind spots in our designs. Blind
spots that are too often addressed by engineers who will make different
decisions based on different approaches.

<Image
    src={shapesComputer}
    invertInDarkMode={true}
    alt="A person working with a computer, expressing their idea accurately through code."
/>

But this is also the nice thing about code. Not only does it make the contract
between our idea and the computer‚Äôs reality concrete and specific...

<Image
    src={shapesParityCode}
    invertInDarkMode={true}
    alt="Two different people, both looking at a code editor depicting code. Both people hold the same idea in their minds."
/>

It makes the contract between _people_ concrete and specific in a way that
visual design can‚Äôt guarantee.

Why should design be any different? Why settle for just sharing a mockup, when
we can share a prototype, or a code snippet, or a message with a description?

There‚Äôs a whole other language of experience design that design tools can‚Äôt
express, and that code can.

<Image
    src={ideasMedia}
    invertInDarkMode={true}
    alt="A person sharing their ideas through different media: writing, speaking, and coding. The recipient clearly understands the sender's ideas."
/>

---

How do you know from a Figma prototype how a screenreader should announce an
interface? Or how it should appear in different screen sizes? How it should
appear when printed, or in different locales?

<Image
    src={passwordMeterVoiceOver}
    width={600}
    alt="A password strength meter being read aloud by a screenreader, indicating that the password is weak."
/>

Code lets us express in unambiguous terms these otherwise-hidden properties of
our work. It lets us add enhancements for technologies like VoiceOver. We‚Äôre
doing a disservice to our customers and our colleagues by omitting or ignoring
these details.

## From ‚ÄúShould‚Äù to ‚ÄúHow can‚Äù

So how do we begin to embrace this power? What needs to change in our approach?

Let's think about what makes designers unique. Our habits of mind include:

    1. Systems thinking
    2. Creativity
    3. Optimism
    4. Collaboration
    5. Communication
    6. Attention to ethical considerations

What would need to change to allow us to harness code as a tool for
communicating?

It seems only fair to ask: _Should Engineers Design?_

And in so doing, it makes sense to think about what makes engineers unique.
Let's look at their habits of mind:

    1. Systems thinking
    2. Creativity
    3. Optimism
    4. Collaboration
    5. Communication
    6. Attention to ethical considerations

That‚Äôs not a typo‚Äîit's the same list. This list comes from the
[National Academy of Engineers](https://www.raeng.org.uk/media/brjjknt3/thinking-like-an-engineer-full-report.pdf);
it‚Äôs their list of 6 habits of mind that every engineer adopts.

**You already think like an engineer. You just use different tools.**

And it's important to embrace these differences in our work. Engineers may
appear to speak a different language, but our goals‚Äîand even our approaches‚Äîare
almost always the same. We should lean into these differences and learn how to
speak their language, adding more nuanced and detailed expressivity to our work.

It‚Äôs not us vs. them. It‚Äôs us, **together.**

All you have to do is ask the questions left unasked by your designs, and answer
those unanswered. Express your ideas with accuracy, or, failing that, embrace
the ambiguity, and allow others to co-author the reality with you.
